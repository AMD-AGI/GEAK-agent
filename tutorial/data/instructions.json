[
    {
        "instruction": "You are a expert in writing Triton operators for efficient GPU programming. Use triton language write a kernel and wrapper according following instruction.\n            The Triton code provides an element-wise addition kernel named `add_kernel` and a corresponding wrapper function `add_wrapper`. The `add_kernel` is a decorated function with `@triton.jit`, enabling Just-In-Time compilation for optimized GPU execution. It receives pointers to two input tensors (`in_ptr0`, `in_ptr1`), an output tensor (`out_ptr`), the number of elements to process (`n_elements`), and a `BLOCK_SIZE`. Within the kernel, `pid` identifies the program's ID for the block dimension. The computation starts by calculating `block_start` as the base index for each block using `pid * BLOCK_SIZE`, and `offsets` as a range from `block_start` up to `BLOCK_SIZE`. A mask is applied using `offsets < n_elements` to prevent out-of-bound memory access, loading tensor values with `tl.load` for both input pointers. The values are summed and stored back in `out_ptr` using `tl.store`, still respecting the mask.\n\n            The `add_wrapper` function orchestrates the setup and execution of the kernel. It initializes the output tensor `out` using `torch.zeros_like(x)` for similar shape and dtype. The function determines the total number of elements using `x.numel()` and computes the number of blocks needed with `num_blocks = (n_elements + BLOCK_SIZE - 1) // BLOCK_SIZE`. Finally, `add_kernel[(num_blocks,)](x, y, out, n_elements, BLOCK_SIZE)` launches the kernel, passing the input and output pointers, number of elements, and block size. The final result is returned in `out`.\n            ",
        "input": "",
        "output": "\nimport torch\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef add_kernel(\n    in_ptr0,\n    in_ptr1,\n    out_ptr,\n    n_elements,\n    BLOCK_SIZE: \"tl.constexpr\",\n):\n    pid = tl.program_id(axis=0)\n    block_start = pid * BLOCK_SIZE\n    offsets = block_start + tl.arange(0, BLOCK_SIZE)\n    mask = offsets < n_elements\n    x = tl.load(in_ptr0 + offsets, mask=mask)\n    y = tl.load(in_ptr1 + offsets, mask=mask)\n    output = x + y\n    tl.store(out_ptr + offsets, output, mask=mask)\n\ndef add_wrapper(x, y):\n    out = torch.zeros_like(x)\n    \n    BLOCK_SIZE = 4\n    n_elements = x.numel()\n\n    # Calculate the number of blocks needed\n    num_blocks = (n_elements + BLOCK_SIZE - 1) // BLOCK_SIZE\n\n    # Launch the kernel\n    add_kernel[(num_blocks,)](x, y, out, n_elements, BLOCK_SIZE)\n\n    return out\n\n\n\n\n",
        "file": "add_example.py",
        "difficulty": "2"
    },
    {
        "instruction": "You are a expert in writing Triton operators for efficient GPU programming. Use triton language write a kernel and wrapper according following instruction.\n            The Triton kernel sin_kernel computes the element-wise sine of a 1D input array. It takes the following parameters: in_ptr0, a pointer to the input data; out_ptr, a pointer to the output data; n_elements, the total number of elements to process; and BLOCK_SIZE, a compile-time constant determining the block of data processed per program instance. The kernel uses tl.program_id(axis=0) to identify which block it is processing and calculates offsets within the data based on the block ID and BLOCK_SIZE. It loads input data using tl.load with masking to prevent out-of-bounds access. After applying tl.sin to compute the sine of each loaded element, it stores the result back into memory using tl.store, again using a mask to ensure only valid memory locations are written. The wrapper function sin_triton initializes the computation by determining the number of elements in the input tensor x, and invokes the sin_kernel, specifying the grid size as the number of elements and setting the BLOCK_SIZE to 4.\n            ",
        "input": "",
        "output": "\nimport triton\nimport triton.language as tl\nimport torch\n\n@triton.jit\ndef sin_kernel(\n    in_ptr0,\n    out_ptr,\n    n_elements,\n    BLOCK_SIZE: \"tl.constexpr\",\n):\n    pid = tl.program_id(axis=0)\n    block_start = pid * BLOCK_SIZE\n    offsets = block_start + tl.arange(0, BLOCK_SIZE)\n    mask = offsets < n_elements\n    x = tl.load(in_ptr0 + offsets, mask=mask)\n    output = tl.sin(x)\n    tl.store(out_ptr + offsets, output, mask=mask)\n\ndef sin_triton(x, out):\n    n_elements = x.numel()\n    sin_kernel[(n_elements,)](x, out, n_elements, BLOCK_SIZE=4)\n\n\n\n",
        "file": "sin_computation.py",
        "difficulty": "2"
    },
    {
        "instruction": "You are a expert in writing Triton operators for efficient GPU programming. Use triton language write a kernel and wrapper according following instruction.\n            The Triton-accelerated function embedding_kernel is specialized for extracting and storing embedding vectors from a weight matrix for a sequence of token IDs. It uses program IDs to determine processing offsets and handles iteration over sequences with BLOCK_N and BLOCK_NN stride sizes. For each sequence, it computes token IDs and uses masks to ensure only valid data is loaded and processed. The weight matrix is addressed using a combination of token IDs and dimension offsets, facilitated by the stride of the weight tensor. The processed vectors are then stored into the 'out' tensor using calculated strides and masks, ensuring each output sequence position receives the correct embedding vector. The wrapping function, embedding, configures and invokes the kernel with appropriate grid settings, aligning the number of warps and stages for optimal performance.\n            ",
        "input": "",
        "output": "\nimport torch\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef embedding_kernel(\n    weight,\n    input_ids,\n    out,\n    vob_start_id,\n    vob_end_id,\n    stride_weight_seq,\n    stride_out_seq,\n    n_ctx,\n    hiden_size: tl.constexpr,\n    BLOCK_DMODEL: tl.constexpr,\n    BLOCK_N: tl.constexpr,\n    BLOCK_NN: tl.constexpr,\n):\n    start_n = tl.program_id(0) * BLOCK_N\n\n    offs_nn = start_n + tl.arange(0, BLOCK_NN)\n    offs_d = tl.arange(0, BLOCK_DMODEL)\n\n    for start_nn in range(0, BLOCK_N, BLOCK_NN):\n        start_nn = tl.multiple_of(start_nn, BLOCK_NN)\n        offs_seq = start_nn + offs_nn\n        n_ctx_mask = offs_seq < n_ctx\n        token_ids = tl.load(input_ids + offs_seq, mask=n_ctx_mask, other=vob_end_id)\n        id_mask = (token_ids >= vob_start_id) & (token_ids < vob_end_id)\n        token_ids = token_ids - vob_start_id\n        dim_mask = offs_d < hiden_size\n        load_mask = id_mask[:, None] & dim_mask[None, :]\n        store_mask = n_ctx_mask[:, None] & dim_mask[None, :]\n        vecs = tl.load(weight + token_ids[:, None] * stride_weight_seq + offs_d[None, :], mask=load_mask, other=0.0)\n        tl.store(out + offs_seq[:, None] * stride_out_seq + offs_d[None, :], vecs, mask=store_mask)\n\n@torch.no_grad()\ndef embedding(input_ids, weight: torch.Tensor, vob_start_id, vob_end_id, out: torch.Tensor):\n    BLOCK_N = 64\n    BLOCK_NN = 1\n    BLOCK_DMODEL = triton.next_power_of_2(weight.shape[1])\n    n_ctx = input_ids.shape[0]\n\n    grid = (triton.cdiv(n_ctx, BLOCK_N), 1, 1)\n\n    embedding_kernel[grid](\n        weight,\n        input_ids,\n        out,\n        vob_start_id,\n        vob_end_id,\n        weight.stride(0),\n        out.stride(0),\n        n_ctx=n_ctx,\n        hiden_size=weight.shape[1],\n        BLOCK_DMODEL=BLOCK_DMODEL,\n        BLOCK_N=BLOCK_N,\n        BLOCK_NN=BLOCK_NN,\n        num_warps=1,\n        num_stages=1,\n    )\n\n\n\n",
        "file": "embedding_triton_kernel.py",
        "difficulty": "3"
    },
    {
        "instruction": "You are a expert in writing Triton operators for efficient GPU programming. Use triton language write a kernel and wrapper according following instruction.\n            The Triton kernel function `rmsnorm_triton` is designed to perform RMS normalization on a given 3D tensor `x`, which is stored in `x_ptr`. The normalization is applied over the last dimension of `x` with a specified size `N_SIZE`. The function takes pointers to the input tensor `x_ptr`, the RMS normalization weights `rms_w_ptr`, and the output tensor `output_ptr`. It also requires the strides for input tensor, weight, and output tensor, as well as the constants `N_SIZE`, `eps`, and `BLOCK_N_SIZE`.\n\n            Within the kernel, `pid_batch` and `pid_m` identify the current batch and row of the matrix being processed. The kernel calculates the variance by iterating over chunks of size `BLOCK_N_SIZE` and accumulating the sum of squares of the elements. This is divided by `N_SIZE` to get the variance. The reciprocal square root of the variance plus epsilon gives the `rstd`. The kernel then normalizes each element by multiplying it with `rstd` and the corresponding weight from `rms_w_ptr`, storing the result in `output_ptr`.\n\n            The wrapper function `rmsnorm_triton_wrapper` takes the input tensor `x`, the weight tensor `rms_w`, and an optional `eps` value. It extracts the batch size, M, and K dimensions from `x`, creates an output tensor of the same shape, and launches the kernel with the appropriate grid configuration.\n            ",
        "input": "",
        "output": "import torch\n\nimport triton\nimport triton.language as tl\n\n\ntorch.manual_seed(1234)\n\n\n@triton.jit\ndef rmsnorm_triton(x_ptr, rms_w_ptr, output_ptr,\n                   stride_x_batch, stride_x_m, stride_x_k,\n                   stride_rms_w,\n                   stride_out_batch, stride_out_m, stride_out_k,\n                   N_SIZE: tl.constexpr, eps: tl.constexpr, BLOCK_N_SIZE: tl.constexpr):\n    pid_batch = tl.program_id(0)\n    pid_m = tl.program_id(1)\n\n    offs_m = pid_batch * stride_x_batch + pid_m * stride_x_m\n    block_N = tl.arange(0, BLOCK_N_SIZE)\n    var = tl.zeros((BLOCK_N_SIZE,), tl.float32)\n    for block_n_start_idx in range(0, N_SIZE, BLOCK_N_SIZE):\n        offs_n = block_n_start_idx + block_N\n        x_ptr_mask = offs_n < N_SIZE\n        x = tl.load(x_ptr + offs_m + offs_n * stride_x_k, mask=x_ptr_mask, other=0.0)\n        var += tl.extra.hip.libdevice.pow(x.to(tl.float32), 2)\n\n    var = tl.sum(var, axis=0) / N_SIZE\n    rstd = tl.math.rsqrt(var + eps)\n\n    # multiply by weight and add bias\n    for block_n_start_idx in range(0, N_SIZE, BLOCK_N_SIZE):\n        offs_n = block_n_start_idx + block_N\n        x_ptr_mask = offs_n < N_SIZE\n        rms_w = tl.load(rms_w_ptr + offs_n * stride_rms_w, mask=x_ptr_mask)\n\n        x = tl.load(x_ptr + offs_m + offs_n * stride_x_k, mask=x_ptr_mask, other=0.0).to(tl.float32)\n        x_hat = x * rstd\n        out = x_hat * rms_w\n        out_off = pid_batch * stride_out_batch + pid_m * stride_out_m + offs_n * stride_out_k\n        tl.store(output_ptr + out_off, out, mask=x_ptr_mask)\n\n\ndef rmsnorm_triton_wrapper(x, rms_w, eps=1e-6):\n    batch, M, K = x.shape\n    assert rms_w.shape[-1] == K\n    out = torch.empty_like(x)\n    rmsnorm_triton[(batch, M,)](x, rms_w, out,\n                                *x.stride(),\n                                *rms_w.stride(),\n                                *out.stride(),\n                                N_SIZE=K, eps=eps, BLOCK_N_SIZE=1024,\n                                )\n    return out\n\n\n\n",
        "file": "rmsnorm.py",
        "difficulty": "2"
    },
    {
        "instruction": "Develop an optimized Triton kernel for Fused Grouped FP8 GEMM aimed at Mixture-of-Experts (MoE) workloads. The kernel must support variable-sized groups (Ragged Batching) where multiple GEMM operations share weights (B) but have different input M dimensions (A). Key requirements include: 1) FP8 support (E4M3) with per-tensor scaling factors for quantization/dequantization, 2) Grouped GEMM scheduling where 'tile_to_group_ptr' maps every tile to its group ID for load balancing, 3) Use a pointer-array ('B_ptr_array') for non-contiguous weight matrices, 4) Wrap host logic in a class 'OptimizedGroupedGEMM', 5) Include a 'test_grouped_gemm' function and 'if __name__ == \"__main__\":' block. CRITICAL CONSTRAINTS: 6) Use standard pointer arithmetic (tl.load with offsets). Do NOT use 'tl.make_block_ptr'. 7) DO NOT define or call any helper functions (like 'get_fp8_dtype') inside the JIT kernel. 8) DO NOT import 'transformer_engine'. Use only 'torch' and 'triton'. 9) For the FP8 data type, you MUST use 'tl.float8e4b8' directly. Do not use 'tl.float8e4m3fn'. 10) The kernel's output should be bfloat16. 11) When performing FP8 matrix multiplication using tl.dot, explicitly cast both input operands to the target FP8 data type (e.g., tl.float8e4b8) immediately before the dot operation to prevent data type errors.",
        "input": "",
        "output": "import torch\nimport triton\nimport triton.language as tl\nfrom typing import List\nimport math\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 128, 'BLOCK_K': 64, 'GROUP_SIZE_M': 8}, num_stages=3, num_warps=8),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 64, 'BLOCK_K': 64, 'GROUP_SIZE_M': 8}, num_stages=3, num_warps=4),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 128, 'BLOCK_K': 64, 'GROUP_SIZE_M': 8}, num_stages=3, num_warps=4),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 64, 'BLOCK_K': 64, 'GROUP_SIZE_M': 8}, num_stages=3, num_warps=4),\n    ],\n    key=['total_tiles', 'K'],\n)\n@triton.jit\ndef grouped_fused_fp8_gemm_kernel_v2(\n    A_ptr, C_ptr,\n    B_ptr_array,\n    M_cumsum_ptr,\n    M_array, N_array, K,\n    scales_ptr,\n    tile_to_group_ptr, tile_offset_ptr,\n    stride_ak, stride_bk, stride_bn, stride_ck,\n    total_tiles,\n    BLOCK_M: tl.constexpr, BLOCK_N: tl.constexpr, BLOCK_K: tl.constexpr,\n    GROUP_SIZE_M: tl.constexpr,\n    NUM_GROUPS: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    \n    group_id = tl.load(tile_to_group_ptr + pid)\n    local_tile_id = tl.load(tile_offset_ptr + pid)\n    \n    M = tl.load(M_array + group_id)\n    N = tl.load(N_array + group_id)\n    m_offset = tl.load(M_cumsum_ptr + group_id)\n    \n    num_pid_m = tl.cdiv(M, BLOCK_M)\n    num_pid_n = tl.cdiv(N, BLOCK_N)\n    num_pid_in_group = GROUP_SIZE_M * num_pid_n\n    group_id_tile = local_tile_id // num_pid_in_group\n    first_pid_m = group_id_tile * GROUP_SIZE_M\n    group_size_m = min(num_pid_m - first_pid_m, GROUP_SIZE_M)\n    pid_m = first_pid_m + (local_tile_id % group_size_m)\n    pid_n = (local_tile_id % num_pid_in_group) // group_size_m\n    \n    scale_base = group_id * 4\n    qscale_a = tl.load(scales_ptr + scale_base + 0)\n    qscale_b = tl.load(scales_ptr + scale_base + 1)\n    dscale_a = tl.load(scales_ptr + scale_base + 2)\n    dscale_b = tl.load(scales_ptr + scale_base + 3)\n    \n    b_ptr = tl.load(B_ptr_array + group_id).to(tl.pointer_type(tl.bfloat16))\n    \n    offs_am = pid_m * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_bn = pid_n * BLOCK_N + tl.arange(0, BLOCK_N)\n    offs_k = tl.arange(0, BLOCK_K)\n    \n    a_ptrs = A_ptr + (m_offset + offs_am[:, None]) * stride_ak + offs_k[None, :]\n    b_ptrs = b_ptr + offs_k[:, None] * stride_bk + offs_bn[None, :] * stride_bn\n    \n    accumulator = tl.zeros((BLOCK_M, BLOCK_N), dtype=tl.float32)\n    \n    for k in range(0, tl.cdiv(K, BLOCK_K)):\n        k_remaining = K - k * BLOCK_K\n        \n        # --- M/N/K Masking ---\n        # A mask: check M bounds (rows) and K bounds (cols)\n        k_mask_a = (offs_am[:, None] < M) & (offs_k[None, :] < k_remaining)\n        \n        # B mask: check N bounds (cols) and K bounds (rows)\n        k_mask_b = (offs_bn[None, :] < N) & (offs_k[:, None] < k_remaining)\n        \n        a_bf16 = tl.load(a_ptrs, mask=k_mask_a, other=0.0)\n        b_bf16 = tl.load(b_ptrs, mask=k_mask_b, other=0.0)\n        \n        a_fp8 = (a_bf16 * qscale_a).to(tl.float8e4b8)\n        b_fp8 = (b_bf16 * qscale_b).to(tl.float8e4b8)\n        \n        accumulator = tl.dot(a_fp8, b_fp8, accumulator)\n        \n        a_ptrs += BLOCK_K\n        b_ptrs += BLOCK_K * stride_bk\n    \n    total_dscale = dscale_a * dscale_b\n    c = accumulator * total_dscale\n    \n    offs_cm = pid_m * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_cn = pid_n * BLOCK_N + tl.arange(0, BLOCK_N)\n    c_ptrs = C_ptr + (m_offset + offs_cm[:, None]) * stride_ck + offs_cn[None, :]\n    c_mask = (offs_cm[:, None] < M) & (offs_cn[None, :] < N)\n    \n    tl.store(c_ptrs, c.to(tl.bfloat16), mask=c_mask)\n\n\nclass OptimizedGroupedGEMM:\n    def __init__(self, B_list: List[torch.Tensor], device='cuda'):\n        self.device = device\n        self.num_groups = len(B_list)\n        self.K = B_list[0].shape[0]\n        self.N = B_list[0].shape[1]\n        self.FP8_MAX = 240.0\n        \n        self.B_list = [b.contiguous() for b in B_list]\n        self.B_ptr_array = torch.tensor(\n            [b.data_ptr() for b in self.B_list],\n            device=device, dtype=torch.int64\n        )\n        \n        self.B_qscales = torch.empty(self.num_groups, device=device, dtype=torch.float32)\n        self.B_dscales = torch.empty(self.num_groups, device=device, dtype=torch.float32)\n        for i, B in enumerate(self.B_list):\n            max_b = B.abs().max().float().item()\n            max_b = max(max_b, 1e-6)\n            self.B_qscales[i] = self.FP8_MAX / max_b\n            self.B_dscales[i] = max_b / self.FP8_MAX\n        \n        self.scales_buffer = torch.empty(self.num_groups * 4, device=device, dtype=torch.float32)\n        for i in range(self.num_groups):\n            self.scales_buffer[i*4 + 1] = self.B_qscales[i]\n            self.scales_buffer[i*4 + 3] = self.B_dscales[i]\n        \n        self._cached_m_splits = None\n        self._cached_schedule = None\n        self._cached_C_out = None\n        \n    def _compute_schedule(self, M_splits: List[int], BLOCK_M=128, BLOCK_N=128):\n        M_cumsum = [0]\n        tile_to_group = []\n        tile_offset = []\n        M_array = []\n        N_array = []\n        \n        for group_id, M in enumerate(M_splits):\n            M_cumsum.append(M_cumsum[-1] + M)\n            M_array.append(M)\n            N_array.append(self.N)\n            \n            num_tiles_m = triton.cdiv(M, BLOCK_M)\n            num_tiles_n = triton.cdiv(self.N, BLOCK_N)\n            \n            for local_id in range(num_tiles_m * num_tiles_n):\n                tile_to_group.append(group_id)\n                tile_offset.append(local_id)\n        \n        return {\n            'M_cumsum': torch.tensor(M_cumsum[:-1], device=self.device, dtype=torch.int32),\n            'M_array': torch.tensor(M_array, device=self.device, dtype=torch.int32),\n            'N_array': torch.tensor(N_array, device=self.device, dtype=torch.int32),\n            'tile_to_group': torch.tensor(tile_to_group, device=self.device, dtype=torch.int32),\n            'tile_offset': torch.tensor(tile_offset, device=self.device, dtype=torch.int32),\n            'total_tiles': len(tile_to_group),\n            'total_M': sum(M_splits),\n        }\n    \n    def _get_schedule(self, M_splits: List[int]):\n        m_tuple = tuple(M_splits)\n        if self._cached_m_splits != m_tuple:\n            self._cached_schedule = self._compute_schedule(M_splits)\n            self._cached_m_splits = m_tuple\n            total_M = self._cached_schedule['total_M']\n            self._cached_C_out = torch.empty((total_M, self.N), device=self.device, dtype=torch.bfloat16)\n        return self._cached_schedule\n    \n    def __call__(self, A_concat: torch.Tensor, M_splits: List[int]) -> torch.Tensor:\n        schedule = self._get_schedule(M_splits)\n        \n        start = 0\n        for i, m in enumerate(M_splits):\n            max_a = A_concat[start:start+m].abs().max().float().item()\n            max_a = max(max_a, 1e-6)\n            qscale_a = self.FP8_MAX / max_a\n            self.scales_buffer[i*4 + 0] = qscale_a\n            self.scales_buffer[i*4 + 2] = 1.0 / qscale_a\n            start += m\n        \n        grid = (schedule['total_tiles'],)\n        \n        grouped_fused_fp8_gemm_kernel_v2[grid](\n            A_concat, self._cached_C_out,\n            self.B_ptr_array,\n            schedule['M_cumsum'],\n            schedule['M_array'], schedule['N_array'], self.K,\n            self.scales_buffer,\n            schedule['tile_to_group'], schedule['tile_offset'],\n            A_concat.stride(0), self.B_list[0].stride(0), self.B_list[0].stride(1), \n            self._cached_C_out.stride(0),\n            schedule['total_tiles'],\n            NUM_GROUPS=self.num_groups,\n        )\n        \n        return self._cached_C_out\n",
        "file": "grouped_gemm_triton_kernel.py",
        "difficulty": "3"
    }
]